영속성 계층을 애플리케이션 계층의 플러그인으로 만들어보자

## 6.1 의존성 역전

육각형 아키텍쳐에서 영속성 어댑터는 주도되는 아웃고잉 어댑터다. 애플리케이션에 의해 호출되기 때문에 서비스가 호출할 포트 인터페이스를 구현한다.

## 6.2 영속성 어댑터의 책임

1. 포트 인터페이스를 통해 입력을 받는다.
2. 입력을 데이터베이스 포맷으로 매핑한다 : JPA 라면 JPA 엔티티 객체로 매핑한다. 핵심은 입력 모델이 애플리케이션 코어에 있기 때문에 영속성 어댑터 내부를 변경하더라도 코어에는 영향이 없다.
3. 입력을 데이터베이스로 보낸다.
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다.

## 6.3 포트 인터페이스 나누기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/901a276c-238e-4bc4-a85e-dc17234839ce/Untitled.png)

보통 위와 같은 방법으로 데이터베이스 연산을 넣어두는데, 인터페이스에서 단 하나의 메서드만 사용하더라도 하나의 ‘넓은’ 포트 인터페이스에 의존성을 갖게 된다.

테스트 시에는 일부 메소드만 모킹해야 하고, 그 떄문에 다른 에러를 볼 수도 있다.

```java
필요없는 화물을 운반하는 무언가에 의존하고 있으면 예상하지 못했던 문제가 생길 수 있다.
- 로버트 C. 마틴
```

인터페이스 분리 원칙(ISP)는 답이 될 수 있다. 오로지 자신이 필요로 하는 메소드만 알 수 있도록 분리한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/011f402a-65b4-4d0e-8a3a-a054a750a898/Untitled.png)

위와 같이 각 서비스는 필요한 메소드에만 의존한다. plug-and-play 라고 해서 좁은 포트를 만들어서 필요한 포트에 꽂기만 하면 된다.

물론 함께 사용될 때가 많은 연산들이 있을 수 있다.

## 6.4 영속성 어댑터 나누기

도메인 클래스(DDD에서의 애그리거트) 하나 당 하나의 영속성 어댑터를 구현할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98bfa92c-54e4-48e4-b0bb-7a70cd4ba821/Untitled.png)

위와 같이 구성하면 도메인 경계를 따라 어댑터들이 자동으로 나뉘어진다.

애그리거트(하나의 단위로 취급될 수 있는 연관 객체의 모음)당 하나의 영속성 어댑터 방식 또한 여러 개의 바운디드 컨텍스트의 영속성 요구사항을 분리하기 위한 좋은 토대가 된다.

바운디드 컨텍스트에서 서로의 영속성 어댑터에 접근하지 않는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b38cf2d-6a40-43a7-ae98-f9979f578282/Untitled.png)

영속성어댑터는 포트를 구현하고 리파지토리로 데이터를 가져온다. 그리고 도메인 엔티티를 매핑해서 호출자에게 반환한다.

## 6.5 데이터베이스 트랜잭션은 어떻게 해야 할까?

트랜잭션 경계는 하나의 특정한 유스케이스에 대해서 일어나는 모든 쓰기 작업에 걸쳐있어야 다같이 롤백될 수 있다. 그래서 이는 영속성 어댑터 호출을 관장하는 서비스에 위임해야한다. @Transactional 을 서비스 클래스에 붙여서 모든 public 메소드가 트랜잭션으로 감싸이게 한다.

## 6.6 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

도메인 코드가 영속성과 관련된 것들로부터 분리되어 풍부한 도메인 모델을 만들 수 있다.